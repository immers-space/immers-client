<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: activities.js</title>
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <script src="https://unpkg.com/immers-client/dist/destination.bundle.js?position=top-right&title=immers-client%20Documentation"></script>
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: activities.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @typedef {string} IRI String representing a unique resource URL
 */
/**
 * @typedef {Object} APObject Object representing an ActivityPub object
 * @property {IRI} id
 * @property {string} type
 */
/**
 * @typedef {Object} APActivity Object representing an ActivityPub activity
 * @property {IRI} id
 * @property {string} type
 * @property {APActor} actor
 */
/**
 * @typedef {Object} APActor Object representing an ActivityPub actor
 * @property {IRI} id
 * @property {string} type
 * @property {IRI} inbox
 * @property {IRI} outbox
 */
/**
 * @typedef {Object} APPlace
 * @property {IRI} id
 * @property {String} type 'Place'
 * @property {String} name Title of the destination
 * @property {String} url link to visit the destination
 * @property {String} audience who can view this object (generally Activities.PublicAddress)
 */

/** Low-level API client-to-server ActivityPub methods */
export class Activities {
  static JSONLDMime = 'application/activity+json'
  static PublicAddress = 'as:Public'
  #token
  /**
   * @param  {APActor} actor The user's actor object
   * @param  {string} homeImmer Protocol and domain of user's home Immers server
   * @param  {APObject} place Place-type object representing this Immersive Web experience
   * @param  {string} [token] OAuth2 token for user's home Immers server
   * @param  {string} [localImmer] Protocol and domain of local Immers server, e.g. https://immers.space
   */
  constructor (actor, homeImmer, place, token, localImmer) {
    this.actor = actor
    this.homeImmer = homeImmer
    this.place = place
    this.#token = token
    this.localImmer = localImmer
    // this.authorizedScopes = null
    this.nextInboxPage = null
    this.nextOutboxPage = null
    this.inboxStartDate = new Date()
    this.outboxStartDate = this.inboxStartDate
    // this.friends = []
  }

  trustedIRI (IRI) {
    return (this.localImmer &amp;&amp; IRI.startsWith(this.localImmer)) || IRI.startsWith(this.homeImmer)
  }

  // lower-level utilities
  async getObject (IRI) {
    if (this.trustedIRI(IRI)) {
      const headers = { Accept: Activities.JSONLDMime }
      if (this.#token) {
        headers.Authorization = `Bearer ${this.#token}`
      }
      const result = await window.fetch(IRI, { headers })
      if (!result.ok) {
        throw new Error(`Object fetch error ${result.message}`)
      }
      return result.json()
    } else {
      throw new Error('Object fetch proxy not implemented')
    }
  }

  postActivity (activity) {
    if (!this.trustedIRI(this.actor.outbox)) {
      throw new Error('Invalid outbox address')
    }
    return window.fetch(this.actor.outbox, {
      method: 'POST',
      headers: {
        'Content-Type': Activities.JSONLDMime,
        Authorization: `Bearer ${this.#token}`
      },
      body: JSON.stringify(activity)
    })
  }

  // collection fetchers
  async inbox () {
    let col
    if (this.nextInboxPage === null) {
      col = await this.getObject(this.actor.inbox)
      if (!col.orderedItems &amp;&amp; col.first) {
        col = await this.getObject(col.first)
      }
    } else if (this.nextInboxPage) {
      col = await this.getObject(this.nextInboxPage)
    }
    this.nextInboxPage = col?.next
    return col
  }

  async outbox () {
    let col
    if (this.nextOutboxPage === null) {
      col = await this.getObject(this.actor.outbox)
      if (!col.orderedItems &amp;&amp; col.first) {
        col = await this.getObject(col.first)
      }
    } else if (this.nextOutboxPage) {
      col = await this.getObject(this.nextOutboxPage)
    }
    this.nextOutboxPage = col?.next
    return col
  }

  async blockList () {
    const blocked = []
    // use blocklist IRI if specified, fallback to immers default
    const blockedIRI = this.actor.streams?.blocked || `${this.homeImmer}/blocked/${this.actor.preferredUsername}`
    let col
    try {
      col = await this.getObject(blockedIRI)
    } catch (err) {
      console.warn('Unable to fetch blocklist: ', err.message)
      return blocked
    }
    if (col.orderedItems?.length) {
      blocked.push(...col.orderedItems)
    } else {
      col = await this.getObject(col.first)
      blocked.push(...col.orderedItems)
    }
    // fetch entire collection
    while (col.next) {
      col = await this.getObject(col.next)
      if (!col.orderedItems?.length) {
        break
      }
      blocked.push(...col.orderedItems)
    }
    return blocked.map(b => (typeof b === 'object' ? b.id : b))
  }

  // activity-specific posting methods
  accept (follow) {
    return this.postActivity({
      type: 'Accept',
      actor: this.actor.id,
      object: follow.id,
      to: follow.actor
    })
  }

  /**
   * "Add" object to the target collection
   * @param  {APObject} object
   * @param  {IRI} target
   */
  add (object, target) {
    return this.postActivity({
      type: 'Add',
      actor: this.actor.id,
      object: object.id,
      target
    })
  }

  arrive () {
    return this.postActivity({
      type: 'Arrive',
      actor: this.actor.id,
      target: this.place,
      to: this.actor.followers,
      summary: `${this.actor.name} arrived at ${this.place.name}.`
    })
  }

  block (blockeeId) {
    return this.postActivity({
      type: 'Block',
      actor: this.actor.id,
      object: blockeeId
    })
  }

  /**
   * Post a create activity for an object
   * @param  {APObject} object New object to be wrapped in Create activity
   * @return {Promise&lt;APActivity>} The resulting Create activity
   */
  create (object) {
    return this.postActivity({
      type: 'Create',
      actor: this.actor.id,
      object
    }).then(res => {
      if (!res.ok) {
        throw new Error('Error creating', res.status, res.body)
      }
      return this.getObject(res.headers.get('Location'))
    })
  }

  follow (targetId) {
    return this.postActivity({
      type: 'Follow',
      actor: this.actor.id,
      object: targetId,
      to: targetId
    })
  }

  friends () {
    const friendsEndpoint = this.actor.endpoints?.friends ?? `${this.actor.id}/friends`
    return this.getObject(friendsEndpoint)
  }

  image (url, to, audience, summary) {
    const obj = {
      url,
      type: 'Image',
      attributedTo: this.actor.id,
      context: this.place,
      to: to.slice()
    }
    if (summary) {
      obj.summary = summary
    }
    if (audience === 'friends' || audience === 'public') {
      obj.to.push(this.actor.followers)
    }
    if (audience === 'public') {
      obj.to.push(Activities.PublicAddress)
    }
    return this.postActivity(obj)
  }

  note (content, to, audience, summary) {
    const obj = {
      content,
      type: 'Note',
      attributedTo: this.actor.id,
      context: this.place,
      to: to.slice()
    }
    if (summary) {
      obj.summary = summary
    }
    if (audience === 'friends' || audience === 'public') {
      obj.to.push(this.actor.followers)
    }
    if (audience === 'public') {
      obj.to.push(Activities.PublicAddress)
    }
    return this.postActivity(obj)
  }

  reject (objectId, recipientId) {
    return this.postActivity({
      type: 'Reject',
      actor: this.actor.id,
      object: objectId,
      to: recipientId
    })
  }

  updateProfile (update) {
    update.id = this.actor.id
    const activity = {
      type: 'Update',
      actor: this.actor.id,
      object: update,
      to: this.actor.followers
    }
    return this.postActivity(activity)
  }

  video (url, to, audience, summary) {
    const obj = {
      url,
      type: 'Video',
      attributedTo: this.actor.id,
      context: this.place,
      to: to.slice()
    }
    if (summary) {
      obj.summary = summary
    }
    if (audience === 'friends' || audience === 'public') {
      obj.to.push(this.actor.followers)
    }
    if (audience === 'public') {
      obj.to.push(Activities.PublicAddress)
    }
    return this.postActivity(obj)
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Activities.html">Activities</a></li><li><a href="ImmersClient.html">ImmersClient</a></li><li><a href="ImmersHUD.html">ImmersHUD</a></li><li><a href="ImmersSocket_ImmersSocket.html">ImmersSocket</a></li></ul><h3>Global</h3><ul><li><a href="global.html#allScopes">allScopes</a></li><li><a href="global.html#catchToken">catchToken</a></li><li><a href="global.html#DestinationOAuthPopup">DestinationOAuthPopup</a></li><li><a href="global.html#ImmerOAuthPopup">ImmerOAuthPopup</a></li><li><a href="global.html#oauthPopup">oauthPopup</a></li><li><a href="global.html#parseHandle">parseHandle</a></li><li><a href="global.html#roles">roles</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sat Sep 11 2021 04:41:01 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
